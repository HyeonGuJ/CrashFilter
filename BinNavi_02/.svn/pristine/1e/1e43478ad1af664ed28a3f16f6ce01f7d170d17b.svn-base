package virtualStack;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.google.security.zynamics.binnavi.API.gui.LogConsole;
import com.google.security.zynamics.binnavi.API.reil.ReilInstruction;
import com.google.security.zynamics.binnavi.API.reil.mono.DefaultStateVector;
import com.google.security.zynamics.binnavi.API.reil.mono.DownWalker;
import com.google.security.zynamics.binnavi.API.reil.mono.IInfluencingState;
import com.google.security.zynamics.binnavi.API.reil.mono.ILattice;
import com.google.security.zynamics.binnavi.API.reil.mono.ILatticeElement;
import com.google.security.zynamics.binnavi.API.reil.mono.ILatticeGraph;
import com.google.security.zynamics.binnavi.API.reil.mono.IStateVector;
import com.google.security.zynamics.binnavi.API.reil.mono.ITransformationProvider;
import com.google.security.zynamics.binnavi.API.reil.mono.InstructionGraphNode;
import com.google.security.zynamics.binnavi.API.reil.mono.MonotoneSolver;

import data.ReilInstructionResolve;


public class VirtualStackVer2 {
	private ILatticeGraph<InstructionGraphNode> graph;

	
	public VirtualStackVer2( ILatticeGraph<InstructionGraphNode> graph ){
		this.graph = graph;
	}

	public class VSLatticeElement2 implements ILatticeElement<VSLatticeElement2>{
		
		private InstructionGraphNode inst;
		private Set<InstructionGraphNode> instList = new HashSet<InstructionGraphNode>();
		private Set<InstructionGraphNode> killList = new HashSet<InstructionGraphNode>();
		
		
		private String reg;
		Map<String, String> virtualStack = new HashMap<String, String>();
		InstructionGraphNode curInstruction;
		Map<Map<?,String[]>,String[]> abstractLocation;

		public void temp()
		{
			abstractLocation= new HashMap<Map<?,String[]>, String[]>();
			
			Map<?,String[]> a = new HashMap<String,String[]>();
			String[] range = {"1","2"};
			range[1]= "2";
			
			abstractLocation.put(a,range);
		}
		
		public void insertVirtualStack(String register , String offset)
		{
			virtualStack.put(register, offset);
		}
		public void deleteVirtualStack(String register)
		{
			virtualStack.remove(register);
		}
		public boolean IsSrcInVirtualStack(ReilInstruction ri)
		{
			String src = ri.getFirstOperand().toString();
			return virtualStack.containsKey(src);
		}
		public boolean IsDestInVirtualStack(ReilInstruction ri)
		{
			String dest = ri.getThirdOperand().toString();
			return virtualStack.containsKey(dest);
		}
		public void setCurInstruction(InstructionGraphNode isgn)
		{
			this.curInstruction=isgn;
		}
		
		
		
		
		
		
		
		public void setInst( InstructionGraphNode inst){
			this.inst = inst;			
		}
		public InstructionGraphNode getInst(){
			return inst;
		}
		public Set<InstructionGraphNode> getInstList( ){
			return instList;
		}
		
		public Set<InstructionGraphNode> getKillList( ){
			return killList;
		}
		
		public void unionInstList(Set<InstructionGraphNode> state){
			this.instList.addAll(state);
		}
		
		public void unionKillList(Set<InstructionGraphNode> killList){
			this.killList.addAll(killList);
		}
		
		public void removeAllInstList(Set<InstructionGraphNode> instList){
			this.instList.removeAll(instList);
		}
		
		public void insertInst(InstructionGraphNode inst){
			this.instList.add(inst);
		}
		
		public void insertKill(InstructionGraphNode inst){
			this.killList.add(inst);
		}
		
		
		
		@Override
		public boolean equals(VSLatticeElement2 rhs) {
			if(rhs.getInstList().containsAll(instList)){
				if(instList.size() == rhs.getInstList().size())
					return true;
			}
			else
				; //error - it is not monotone
			
			return false;
		}

		@Override
		public boolean lessThan(VSLatticeElement2 rhs) {
			if(rhs.getInstList().containsAll(instList)){
				if(instList.size() < rhs.getInstList().size())
					return true;
			}
			else
				; //error - it is not monotone
			
			return false;
		}
		
		

	}
	
	//This function is used to combine states in each state positions of program.
	public class VSLattice2 implements ILattice<VSLatticeElement2, Object>{
		 
		
		
		@Override
		public VSLatticeElement2 combine( List<IInfluencingState<VSLatticeElement2, Object>> states ) {
			VSLatticeElement2 combinedState = new VSLatticeElement2();
			
			//Union all the predecessor's state
			for ( IInfluencingState<VSLatticeElement2, Object> state : states ){
				combinedState.unionInstList(state.getElement().getInstList());				
			}
			
			return combinedState;
		}
	}
	
	public class RDTransferFunction implements ITransformationProvider<InstructionGraphNode, VSLatticeElement2>{
		@Override
		public VSLatticeElement2 transform(
				InstructionGraphNode node,
				VSLatticeElement2 currentState,
				VSLatticeElement2 inputState
				) {

			

			//each InstructionGraphNodes like LDM and STM, we can resolve the memory access operand using value-set analysis result
			VSLatticeElement2 transformedState = new VSLatticeElement2();
						
			transformedState.unionInstList(inputState.getInstList());
			transformedState.removeAllInstList(currentState.getKillList());
			

			if(!(ReilInstructionResolve.resolveReilInstructionDest(node).isEmpty())){
				//ReilInstruction temp = node.getInstruction();
				//InstructionGraphNode t2 = new InstructionGraphNode(ReilInstructionResolve.changeDest(temp, "t0"));
				
				
				/*if(node.getInstruction().getAddress().toLong()% 0x100 == 0)
				{
					LogConsole.log(node.getInstruction()+"\n");
					for(InstructionGraphNode gn : transformedState.getInstList())
					{
						//LogConsole.log("\tgn : " +gn+"\n");
						if(gn.getInstruction().getThirdOperand().getValue().indexOf(0)=='t')
						{
					
						}
					}
				}*/
				transformedState.insertInst(node);
			}
					
			
			transformedState.unionKillList(currentState.getKillList());
			
			return transformedState;
		}
	}
	
	

	
	public  IStateVector<InstructionGraphNode, VSLatticeElement2> initializeState(ILatticeGraph<InstructionGraphNode> graph){
		
		 VSLatticeElement2 state;
		 IStateVector<InstructionGraphNode, VSLatticeElement2> startVector = 
				 new DefaultStateVector<InstructionGraphNode, VSLatticeElement2>();
		 
		 //gathering the kill set of each instruction 
		 //After memory access analysis, we have to use the results.
		 for (InstructionGraphNode defInst1 : graph.getNodes()){
			 
			 state = new VSLatticeElement2();
			 for (InstructionGraphNode defInst2 : graph.getNodes()){
				 
				 //Some time later we will add VSA and have to add some code for new kill set considering memory
				 if(ReilInstructionResolve.isSameDefinition(defInst1, defInst2)){
					 state.insertKill(defInst2);
				 }
			 }
			 startVector.setState(defInst1, state);
		 }
		
		return startVector;
	}
	
	public IStateVector<InstructionGraphNode, VSLatticeElement2> reachingDefinitionAnalysis() {
//		 MessageBox.showInformation(null, "MenuPlugin test!!");
		 VSLattice2 lattice;
		 IStateVector<InstructionGraphNode, VSLatticeElement2> startVector;
		 IStateVector<InstructionGraphNode, VSLatticeElement2> endVector;
		 ITransformationProvider<InstructionGraphNode, VSLatticeElement2> transferFunction;
		 DownWalker<InstructionGraphNode> walker;
		 MonotoneSolver<InstructionGraphNode, VSLatticeElement2, Object, VSLattice2> solver;


		 lattice = new VSLattice2();
		 
		 startVector = initializeState(graph);
		 transferFunction = new RDTransferFunction();
		 walker = new DownWalker<InstructionGraphNode>();
		 solver = new MonotoneSolver<InstructionGraphNode, VSLatticeElement2, Object, VSLattice2>(
				 graph, lattice, startVector, transferFunction, walker
				 );
		 

		 return endVector = solver.solve();			 
	}
	
	public void printVS(IStateVector<InstructionGraphNode, VSLatticeElement2> endVector){	 
	
		 VSLatticeElement2 state = null;
		 for( InstructionGraphNode inst : graph.getNodes() ){
			 state = endVector.getState(inst);
			 LogConsole.log("instruction : ");
			 LogConsole.log(inst.getInstruction().toString());
			 LogConsole.log("\n");
		 
			 for( InstructionGraphNode reachingInst : state.getInstList()){
				 LogConsole.log("\t" + reachingInst.getInstruction().toString());
				 LogConsole.log("\n");
			 }
		 }
	}
	
}
