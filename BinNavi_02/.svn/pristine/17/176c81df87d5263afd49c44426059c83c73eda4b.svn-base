package staticAnalysis;

import java.util.ArrayList;
import java.util.List;

import com.google.security.zynamics.binnavi.API.disassembly.Address;
import com.google.security.zynamics.binnavi.API.disassembly.Function;
import com.google.security.zynamics.binnavi.API.disassembly.Instruction;
import com.google.security.zynamics.binnavi.API.disassembly.Operand;
import com.google.security.zynamics.binnavi.API.gui.LogConsole;
import com.google.security.zynamics.binnavi.API.reil.mono.DefaultStateVector;
import com.google.security.zynamics.binnavi.API.reil.mono.DownWalker;
import com.google.security.zynamics.binnavi.API.reil.mono.ILatticeGraph;
import com.google.security.zynamics.binnavi.API.reil.mono.IStateVector;
import com.google.security.zynamics.binnavi.API.reil.mono.ITransformationProvider;
import com.google.security.zynamics.binnavi.API.reil.mono.InstructionGraphNode;
import com.google.security.zynamics.binnavi.API.reil.mono.MonotoneSolver;

import crashfilter.va.env.IRSetManager;
import crashfilter.va.env.LocLattice;
import crashfilter.va.env.LocLatticeElement;
import crashfilter.va.env.RTable;
import crashfilter.va.memlocations.MLocException;
import data.ReilInstructionResolve;

public class LocAnalysis {
	private ILatticeGraph<InstructionGraphNode> graph;
	HeapChecker heapChecker = new HeapChecker();
	
	private class HeapChecker
	{
		public List<String> allocList ;
		private List<Instruction> heapInstList = new ArrayList<Instruction>();	
		
		public HeapChecker()
		{
			allocList = new ArrayList<>();
			allocList.add("alloc");
			allocList.add("malloc");
			allocList.add("calloc");
			allocList.add("realloc");
			
			allocList.add("xalloc");
			allocList.add("xmalloc");
			allocList.add("xcalloc");
			allocList.add("xrealloc");
			
			allocList.add("HeapAlloc");
			allocList.add("farmalloc");
			allocList.add("farcalloc");
		}
		public boolean isAllocateFuction(String str)
		{
			return allocList.contains(str);
		}
		public boolean eaxHeapMemoryCheck(long reilAddr)
		{
			reilAddr /= 0x100;
			for(Instruction inst : heapChecker.heapInstList)
			{
				if (inst.getAddress().toLong() == reilAddr)
				{
					return true;
				}
			}
			return false;			
		}
	}
	public LocAnalysis( ILatticeGraph<InstructionGraphNode> graph ){
		this.graph = graph;
	}

	public IStateVector locAnalysis() throws MLocException
	{
	
			 
		 LocLattice lattice;
		 IStateVector<InstructionGraphNode, LocLatticeElement> startVector;
		 IStateVector<InstructionGraphNode, LocLatticeElement> endVector;
		 
		 ITransformationProvider<InstructionGraphNode, LocLatticeElement> transferFunction;
		 DownWalker<InstructionGraphNode> walker;
		 MonotoneSolver<InstructionGraphNode, LocLatticeElement, Object, LocLattice> solver;


		 lattice = new LocLattice();
		 
		 startVector = initializeState(graph);
		 transferFunction = new LocTransferFunction();
		 walker = new DownWalker<InstructionGraphNode>();
		 solver = new MonotoneSolver<InstructionGraphNode, LocLatticeElement, Object, LocLattice>(
				 graph, lattice, startVector, transferFunction, walker
				 );
		 

		 endVector = solver.solve();
		 
		 return endVector;
	}
	 
	
	private IStateVector<InstructionGraphNode, LocLatticeElement> initializeState(
			ILatticeGraph<InstructionGraphNode> graph2) throws MLocException {

		IStateVector<InstructionGraphNode, LocLatticeElement> startVector = 
				 new DefaultStateVector<InstructionGraphNode, LocLatticeElement>();
		
		List<InstructionGraphNode> instList = graph2.getNodes();
		LocLatticeElement state ;
		
		
		
		for (InstructionGraphNode inst : graph.getNodes()){
			 
			state = new LocLatticeElement();
			
			RTable rtable = new RTable();
			IRSetManager irsm = IRSetManager.getIRSetManager();
			irsm.setRTable(rtable);
			

			rtable = irsm.initFirst();			
			rtable = irsm.init();			
			
			state.setInst(inst);
			state.setRTable(rtable);
			
			startVector.setState(inst, state);
		}
		
		return startVector;
	}
	public class LocTransferFunction implements ITransformationProvider<InstructionGraphNode, LocLatticeElement>{
		@Override
		public LocLatticeElement transform(
				InstructionGraphNode node,
				LocLatticeElement currentState,
				LocLatticeElement inputState
				) {

			
			LocLatticeElement transformedState = new LocLatticeElement();
			RTable inputRTable = inputState.getRTable();
			RTable currentRTable = currentState.getRTable();
			
			RTable result = inputRTable.combine(currentRTable);
			IRSetManager irsm = IRSetManager.getIRSetManager();		
			
			try {
				irsm.oneReilInst(result, node.getInstruction());
			} catch (MLocException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			result = irsm.getRTable();
			
			
			long instLong = node.getInstruction().getAddress().toLong();
			if(heapChecker.eaxHeapMemoryCheck(instLong))
			{
				try {
					result = irsm.initEax2Heap();
				} catch (MLocException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
			
			
			transformedState.setInst(node);
			transformedState.setRTable(result);			
			currentState.setRTable(result);
			return transformedState;
		}
	}
	
	public void printLoc(IStateVector<InstructionGraphNode, LocLatticeElement> endVector){	 

		LocLatticeElement state = null;
		for( InstructionGraphNode inst : graph.getNodes() ){
			 state = endVector.getState(inst);
			 LogConsole.log("instruction : ");
			 LogConsole.log(inst.getInstruction().toString());
			 LogConsole.log("\n");
			 state.getRTable().printRTable();
		 }
	}
	public void deleteTempReg(IStateVector<InstructionGraphNode, LocLatticeElement> endVector)
	{
		LocLatticeElement state = null;
		for( InstructionGraphNode inst : graph.getNodes() ){
			 state = endVector.getState(inst);
			 state.getRTable().deleteTempReg();
		 }
	}
	
	public void findHeapAllocation(Function function)
	{		
		List<InstructionGraphNode> lg =graph.getNodes();
		Address funcAddr;
		boolean savePoint = false;
		
		for(InstructionGraphNode ign : lg)
		{		
			
			funcAddr = ign.getInstruction().getAddress();
			long funcaddrl = funcAddr.toLong();
			if(funcaddrl % 0x100 == 0)
			{			
				funcaddrl /= 0x100;
				Instruction inst = ReilInstructionResolve.findNativeInstruction(function, funcaddrl);
				
				System.out.println(inst);
				if(savePoint)
				{
					heapChecker.heapInstList.add(inst);
					savePoint = false;
				}
				
				for(Operand op : inst.getOperands())
				{
					System.out.println(op);
					if(heapChecker.isAllocateFuction(op.toString()))
					{
						savePoint = true;
					}
				}
			}	
		}
		for(Instruction i : heapChecker.heapInstList)
		{
			System.out.println(i);
		}
		
		
		
	}
}
