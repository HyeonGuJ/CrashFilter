package staticAnalysis;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.Stack;

import com.google.security.zynamics.binnavi.API.disassembly.View;
import com.google.security.zynamics.binnavi.API.gui.LogConsole;
import com.google.security.zynamics.binnavi.API.reil.ReilHelpers;
import com.google.security.zynamics.binnavi.API.reil.ReilOperand;
import com.google.security.zynamics.binnavi.API.reil.mono.ILatticeGraph;
import com.google.security.zynamics.binnavi.API.reil.mono.IStateVector;
import com.google.security.zynamics.binnavi.API.reil.mono.InstructionGraphEdge;
import com.google.security.zynamics.binnavi.API.reil.mono.InstructionGraphNode;

import crashfilter.va.MLocAnalysis.env.EnvLatticeElement;
import crashfilter.va.memlocations.MLocException;
import data.ReilInstructionResolve;

public class DefUseChain {
	private Map<InstructionGraphNode, List<InstructionGraphNode>> defUseChains = new HashMap<InstructionGraphNode, List<InstructionGraphNode>>();
	IStateVector<InstructionGraphNode, ReachingDefinitionAnalysis.RDLatticeElement> RDResult;
	ILatticeGraph<InstructionGraphNode> graph;
	List<DefUseGraph> duGraphs = new ArrayList<DefUseGraph>();
	IStateVector<InstructionGraphNode, EnvLatticeElement> envResult;
	Long crashPointAddress;
	
	public void setEnvResult(	IStateVector<InstructionGraphNode, EnvLatticeElement> envResult) {
		this.envResult = envResult;
		
	}
	
	public DefUseChain(
			IStateVector<InstructionGraphNode, ReachingDefinitionAnalysis.RDLatticeElement> RDResult,
			ILatticeGraph<InstructionGraphNode> graph,
			Long crashPointAddress) {
		this.RDResult = RDResult;
		this.graph = graph;
		this.crashPointAddress=crashPointAddress;
	}

	private boolean isDefUsed(InstructionGraphNode def, InstructionGraphNode use)  {
		List<ReilOperand> destList = ReilInstructionResolve
				.resolveReilInstructionDest(def);
		List<ReilOperand> srcList = ReilInstructionResolve
				.resolveReilInstructionSrc(use);

		// if source set is empty, we don't need to check anymore
		if (srcList.isEmpty()) {
			return false;
		}
		
		// if def is crash point, we need to check src too.
		Long defAddr = def.getInstruction().getAddress().toLong();
		if(defAddr/0x100 == crashPointAddress)
		{
			List<ReilOperand> defSrcList = ReilInstructionResolve.resolveReilInstructionSrc(def);
			for(ReilOperand defSrc : defSrcList)
			{
				for(ReilOperand useSrc : srcList)
				{	
					/*System.out.println("----");
					System.out.println("def - "+def.getInstruction());
					System.out.println("   use - "+use.getInstruction());*/
					if (ReilHelpers.isRegister(defSrc) && defSrc.getValue().charAt(0)!= 't')
					{
						if (defSrc.getValue().equals(useSrc.getValue())) {
							System.out.println("O");
							return true;
						}					
					}
				}
			}
			return false;
		}
		
		
		switch (ReilInstructionResolve.getKindInst(use)) {
		case STM:
			switch (ReilInstructionResolve.getKindInst(def)) {
			case STM:
				return false;
			case OTHERS:
			case LDM:
				for (ReilOperand dest : destList) {
					if (ReilHelpers.isRegister(dest)) {
						if (dest.getValue().equals(
								use.getInstruction().getFirstOperand()
										.getValue())) {
							String ss = "Def: "+ def.toString()+"Use: "+use.toString()+"\n";
							//LogConsole.log(ss);
							return true;
						} else
							return false;
					}
				}
			}
		case LDM:
			switch (ReilInstructionResolve.getKindInst(def)) {
			case STM:
				// In case of global memory access
				// We can be aware of the position of direct memory access, so
				// we are able to consider this case

				//we can analyze stack memory now. 15.12.08
			
				if (ReilInstructionResolve.isLiteralDirectAccess(use)) {
					if (ReilInstructionResolve.isLiteralDirectAccess(def)) {
						if (use.getInstruction().getFirstOperand()
								.getValue()
								.equals(def.getInstruction().getThirdOperand().getValue())) {
							return true;
						} else
							return false;
					} else if (ReilInstructionResolve.isRegisterIndirectAccess(def))
						return true;
				} else if (ReilInstructionResolve.isRegisterIndirectAccess(use)
						&& ReilInstructionResolve.isLiteralDirectAccess(def)) {
					return true;
				}

				return true;
			case LDM:
			case OTHERS:
				for (ReilOperand dest : destList) {
					for (ReilOperand src : srcList) {
						if (dest.getValue().equals(src.getValue()))
							return true;
					}
				}
				return false;
			}
		default:
			switch (ReilInstructionResolve.getKindInst(def)) {
			case STM:
				return false;
			case OTHERS:
			case LDM:
				for (ReilOperand dest : destList) {
					for (ReilOperand src : srcList) {
						if (ReilHelpers.isRegister(dest)
								&& ReilHelpers.isRegister(src)) {
							if (dest.getValue().equals(src.getValue())) {
								return true;
							}
						}
					}
				}
			}
		}
		return false;
	}

	// we have to add some memory related task after VSA
	public void defUseChaining() {
		List<InstructionGraphNode> uses = null;

		int count =0;
		int count2 =0;
		for (InstructionGraphNode def : graph.getNodes()) 
		{
			uses = new ArrayList<InstructionGraphNode>();

		
			for (InstructionGraphNode use : graph.getNodes()) {
				boolean flag = (def != use)	&& RDResult.getState(use).getInstList().contains(def)	&& isDefUsed(def, use);
				if (flag) {
					uses.add(use);
					count2 ++;
				}	
			}
			
			// Here, if there is no any use that uses the relevant def, we just
			// ignore the def
			if (!uses.isEmpty()) {
				defUseChains.put(def, uses);
			}
		}
		LogConsole.log("count1 : "+count+"\n");
		LogConsole.log("count2 : "+count2+"\n");
	}

	public void printChain() {

		for (Entry<InstructionGraphNode, List<InstructionGraphNode>> defUseChain : defUseChains
				.entrySet()) {
			LogConsole.log("<def> : "
					+ defUseChain.getKey().getInstruction().toString() + "\n");
			for (InstructionGraphNode use : defUseChain.getValue()) {
				LogConsole.log("\t [use] : " + use.getInstruction().toString()
						+ "\n");
			}
			LogConsole.log("\n");
		}

	}

	public void printDuGraph(DefUseGraph duGraph) {
		if (duGraph.getNodes().isEmpty()) {
			LogConsole.log("graph empty!!\n");
		}

		for (DefUseNode node : duGraph.getNodes()) {
			LogConsole.log("[Node] "
					+ node.getInst().getInstruction().toString() + " : \n");
			for (DefUseNode outgoingNode : node.getChildren()) {
				LogConsole.log("\t" + outgoingNode.getInst().toString() + "\n");
			}
			LogConsole.log("\n");
		}

	}

	public List<DefUseGraph> getDuGraphs() {
		return duGraphs;
	}

	public void createDefUseGraph(InstructionGraphNode inst) {
		Map<InstructionGraphNode, DefUseNode> visitedNodes = new HashMap<InstructionGraphNode, DefUseNode>();
		DefUseGraph duGraph = new DefUseGraph();

		// for( InstructionGraphNode inst : defUseChains.keySet()){
		// if(!visitedNodes.containsKey(inst)){
		DefUseNode duNode = new DefUseNode(inst);
		createDefUseGraph(duGraph, visitedNodes, duNode);
		// }
		// }

		duGraphs.add(duGraph);
	}

	// using recursion for creating DEF-USE Graph
	private void createDefUseGraph(DefUseGraph duGraph,
			Map<InstructionGraphNode, DefUseNode> visitedNodes,
			DefUseNode duNode) {

		duGraph.addNode(duNode);
		visitedNodes.put(duNode.getInst(), duNode);
		if (defUseChains.containsKey(duNode.getInst())) {

			for (InstructionGraphNode use : defUseChains.get(duNode.getInst())) {
				if (visitedNodes.containsKey(use)) {
					DefUseEdge duEdge = new DefUseEdge(duNode,visitedNodes.get(use));
					duNode.link(duNode, visitedNodes.get(use), duEdge);
					duGraph.addEdge(duEdge);
				} else {
					DefUseNode newNode = new DefUseNode(use);
					DefUseEdge duEdge = new DefUseEdge(duNode, newNode);
					duNode.link(duNode, newNode, duEdge);
					duGraph.addEdge(duEdge);
					createDefUseGraph(duGraph, visitedNodes, newNode);
				}
			}
		}

	}

	@SuppressWarnings("unused")
	public class DefUseNode {
		private InstructionGraphNode inst;
		private List<DefUseNode> children = new ArrayList<DefUseNode>();
		private List<DefUseNode> parents = new ArrayList<DefUseNode>();
		
		private List<DefUseEdge> incomingEdges = new ArrayList<DefUseEdge>();
		private List<DefUseEdge> outcomingEdges = new ArrayList<DefUseEdge>();

		DefUseNode(final InstructionGraphNode inst) {
			this.inst = inst;
		}

		public InstructionGraphNode getInst() {
			return inst;
		}

		public List<DefUseNode> getChildren() {
			return children;
		}

		public List<DefUseNode> getParents() {
			return parents;
		}

		public List<DefUseEdge> getIncomingEdges() {
			return incomingEdges;
		}

		public List<DefUseEdge> getOutcomingEdges() {
			return outcomingEdges;
		}

		public void addChild(DefUseNode child) {
			children.add(child);
		}

		public void addParent(DefUseNode parent) {
			parents.add(parent);
		}

		public void addIncomingEdge(DefUseEdge incomingEdge) {
			incomingEdges.add(incomingEdge);
		}

		public void addOutComingEdge(DefUseEdge outcomingEdge) {
			outcomingEdges.add(outcomingEdge);
		}

		public void removeChild(DefUseNode child) {
			children.remove(child);
		}

		public void removeParent(DefUseNode parent) {
			parents.remove(parent);
		}

		public void removeIncomingEdge(DefUseEdge incomingEdge) {
			incomingEdges.remove(incomingEdge);
		}

		public void removeOutComingEdge(DefUseEdge outcomingEdge) {
			outcomingEdges.remove(outcomingEdge);
		}

		void link(final DefUseNode source, final DefUseNode target,
				final DefUseEdge edge) {
			if ((source != null) && (target != null) && (edge != null)) {
				target.addParent(source);
				source.addChild(target);
				target.addIncomingEdge(edge);
				source.addOutComingEdge(edge);
			} else
				return;
		}

		void unlink(final DefUseNode source, final DefUseNode target,
				final DefUseEdge edge) {
			if ((source != null) && (target != null) && (edge != null)) {
				target.removeParent(source);
				source.removeChild(target);
				target.removeIncomingEdge(edge);
				source.removeOutComingEdge(edge);
			} else
				return;
		}

	}

	@SuppressWarnings("unused")
	public class DefUseEdge {
		private DefUseNode source;
		private DefUseNode target;

		public DefUseEdge(DefUseNode source, DefUseNode target) {
			this.source = source;
			this.target = target;
		}

		public DefUseNode getSource() {
			return source;
		}

		public DefUseNode getTarget() {
			return target;
		}

	}

	@SuppressWarnings("unused")
	public class DefUseGraph {
		private List<DefUseNode> nodes = new ArrayList<DefUseNode>();
		private List<DefUseEdge> edges = new ArrayList<DefUseEdge>();

		DefUseGraph() {

		}

		public List<DefUseNode> getNodes() {
			return nodes;
		}

		public List<DefUseEdge> getEdges() {
			return edges;
		}

		public void addNode(DefUseNode node) {
			nodes.add(node);
		}

		public void addEdge(DefUseEdge edge) {
			edges.add(edge);
		}

	}

}
