package virtualStack;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

import com.google.security.zynamics.binnavi.API.gui.LogConsole;
import com.google.security.zynamics.binnavi.API.reil.OperandSize;
import com.google.security.zynamics.binnavi.API.reil.ReilInstruction;
import com.google.security.zynamics.binnavi.API.reil.ReilOperand;
import com.google.security.zynamics.binnavi.API.reil.mono.ILatticeGraph;
import com.google.security.zynamics.binnavi.API.reil.mono.InstructionGraphNode;

import data.ReilInstIndex;

public class VS3 {

	private ILatticeGraph<InstructionGraphNode> reilGraph ;
	Map<Aloc,Aloc> abstractLocation ;	
	int count;
	private final static Map<String, ReilInstIndex> instStringToInstValue = new HashMap<String, ReilInstIndex>();
	static {
		instStringToInstValue.put("add", ReilInstIndex.ADD);
		instStringToInstValue.put("and", ReilInstIndex.AND);
		instStringToInstValue.put("bisz", ReilInstIndex.BISZ);
		instStringToInstValue.put("bsh", ReilInstIndex.BSH);
		instStringToInstValue.put("div", ReilInstIndex.DIV);
		instStringToInstValue.put("jcc", ReilInstIndex.JCC);
		instStringToInstValue.put("ldm", ReilInstIndex.LDM);
		instStringToInstValue.put("mod", ReilInstIndex.MOD);
		instStringToInstValue.put("mul", ReilInstIndex.MUL);
		instStringToInstValue.put("nop", ReilInstIndex.NOP);
		instStringToInstValue.put("or", ReilInstIndex.OR);
		instStringToInstValue.put("stm", ReilInstIndex.STM);
		instStringToInstValue.put("str", ReilInstIndex.STR);
		instStringToInstValue.put("sub", ReilInstIndex.SUB);
		instStringToInstValue.put("undef", ReilInstIndex.UNDEF);
		instStringToInstValue.put("unkn", ReilInstIndex.UNKNOWN);
		instStringToInstValue.put("xor", ReilInstIndex.XOR);
	}
	
	public VS3(ILatticeGraph<InstructionGraphNode> graph)
	{
		reilGraph = graph;
		abstractLocation = new HashMap<Aloc,Aloc>();	
		init();
	}
	private void init()
	{
		Aloc esp = new Aloc("esp");
		Aloc stack = new Aloc("stack");
		abstractLocation.put(esp, stack);
		count=0;
	}
	public void analysis()
	{
		LogConsole.log("---------Start-----------\n");
		for (InstructionGraphNode inst : reilGraph.getNodes())
		{
			if(inst.getInstruction().getAddress().toLong()% 0x100 == 0)
			{
				deleteTempRegster();
			}
			LogConsole.log(inst.getInstruction().toString()+"\n");
			operation(inst.getInstruction());
			print();
			LogConsole.log("--------------------\n");
		}
		
		deleteTempRegster();
		print();
		LogConsole.log("-----------end---------\n");
	}

	public void print()
	{
		Set<Aloc> alocSet = abstractLocation.keySet();
		Iterator<Aloc> alocIter = alocSet.iterator();
		while(alocIter.hasNext())
		{
			Aloc k = alocIter.next();
			k.printAloc();
			LogConsole.log(" : ");
			abstractLocation.get(k).printAloc();
			
		}
	}
	

	

	public void operation(ReilInstruction inst)
	{
		ReilOperand op1 = inst.getFirstOperand();
		ReilOperand op2 = inst.getSecondOperand();
		ReilOperand op3 = inst.getThirdOperand();
		
		Aloc op1Aloc;
		Aloc op2Aloc;
		Aloc op3Aloc;
		Aloc tempKey;
		Aloc tempValue;
		Aloc temp;
		switch (instStringToInstValue.get(inst.getMnemonic())) {
			case ADD: // addition
				tempKey = new Aloc(op1.getValue());
				tempKey = searchKey(tempKey);
				tempKey = abstractLocation.get(tempKey);
				if(tempKey !=null)
				{
					String subValue = tempKey.firstRange.min;
					if(subValue.equals("0"))
					{
						subValue = op2.getValue();
					}
					else	
					{
						subValue = subValue+"+"+op2.getValue();
					}
					tempValue = new Aloc(op1.getValue(),subValue,subValue);
					tempKey = new Aloc(op3.getValue());
					abstractLocation.put(tempKey, tempValue);
				}
				else
				{
					LogConsole.log("null\n");
				}
				break;
			case AND: // binary and
				if(op2.getValue().equals("4294967295") && op2.getType().equals(OperandSize.OPERAND_SIZE_DWORD))
				{
					op1Aloc = new Aloc(op1.getValue());
					if((temp = searchKey(op1Aloc))!=null)
					{
						tempValue=abstractLocation.get(temp);;
					}
					else 
					{
						tempValue = op1Aloc;
					}
					tempKey = new Aloc(op3.getValue());
					abstractLocation.put(tempKey, tempValue);
				}
				else
				{
					//notyet
					LogConsole.log("notYet\n");
					tempKey = new Aloc(op3.getValue());
					tempValue = new Aloc(op1.getValue());
					abstractLocation.put(tempKey, tempValue);
				}
				break;
			case BISZ: // boolean is zero
				break;
			case BSH: // binary shift
				break;
			case DIV: // unsigned division
				break;
			case JCC:
				break;
			case LDM:
				if(true)
				{

				}
			case MUL: // unsigned multiplication
			case NOP: // no operation
			case OR: // bitwise Or
				break;
			case STM: // store to memory
				op3Aloc = new Aloc(op3.getValue());
				if((temp = searchKey(op3Aloc))!=null)
				{
					tempKey=abstractLocation.get(temp);
					tempValue = new Aloc(op1.getValue());
					abstractLocation.put(tempKey, tempValue);
				}
				else 
				{
					tempKey = op3Aloc;
					tempValue = new Aloc("??");
					abstractLocation.put(tempKey, tempValue);
					
					tempKey = tempValue;
					tempValue = new Aloc(op1.getValue());
					abstractLocation.put(tempKey, tempValue);
					
				}
				
				break;
			case STR: // store to register
				tempKey = new Aloc(op3.getValue());
				tempValue = new Aloc(op1.getValue());
				abstractLocation.put(tempKey, tempValue);
				break;
			case SUB: // subtract
				op3Aloc = new Aloc(op3.getValue());
				if((temp = searchKey(op3Aloc))!=null)
				{
					tempKey=abstractLocation.get(temp);;
				}
				else 
				{
					tempKey = op3Aloc;
				}
				tempValue = subOperation(op1, op2);
				abstractLocation.put(tempKey, tempValue);
				
			case UNDEF:
			case UNKNOWN: // unknown operation ( placeholder instruction )
				break;
			case XOR:
			default: // Exception
				break;
		}

	}
	private Aloc subOperation(ReilOperand op1, ReilOperand op2)
	{
		Aloc result;
		Aloc op1Aloc = new Aloc(op1.getValue());
		Aloc op2Aloc = new Aloc(op2.getValue());
		Aloc temp;
		
		if(  (temp=searchKey(op1Aloc)) != null )
		{
			op1Aloc = abstractLocation.get(temp);
		}
		if(  (temp=searchKey(op2Aloc)) != null )
		{
			op2Aloc = abstractLocation.get(temp);
		}
		
		result = new Aloc(	op1Aloc.reg, 
							op1Aloc.firstRange.min+"-"+op2.toString(),
							op1Aloc.firstRange.max+"-"+op2.toString());
		return result;
	}
	private Aloc searchKey(Aloc inputAloc)
	{
		//esp != esp+[4,4]
		//but both esp and esp+4 is in stack......
		for(Aloc aloc : abstractLocation.keySet())
		{
			if( aloc.reg.equals(inputAloc.reg) &&
				aloc.firstRange.equals(inputAloc.firstRange)&&
				aloc.secondRange.equals(inputAloc.secondRange))
			{
				LogConsole.log("searchKey-exist "+inputAloc.reg+"\n");
				return aloc;
			}
		}
		
		return null;
	}
	
	private boolean hasRegisterInKey(ReilOperand reilOperand)
	{
		boolean result = false;
		
		for(Aloc aloc : abstractLocation.keySet())
		{
			if( aloc.reg.equals(reilOperand.getValue()) )
			{
				result = true;
			}
		}
		return result;
	}
	private void deleteTempRegster()
	{
		for(Aloc aloc : abstractLocation.keySet())
		{
			String str = aloc.reg;
			if(str.charAt(0)=='t')
			{
				abstractLocation.remove(aloc);
			}
		}
	}


}
